## UltraOS优化

### trap优化

经过测试，内核syscall+sfence.vma 1000000次耗时8.6s，根据内核syscall0.4s，可以计算出sfence.vma耗时为8.2s(±0.2s)，而每次trap需要执行两次，而trap 24.2s，意味着这条指令是trap过程中最耗时的部分。

### 初始进程内存回收

在评测系统下，任何自定义的程序都必须要放入在OS程序中一同打包，我们采用的策略是先放置于内存中，然后初始化写入至外存，再exec initproc，initproc会exec shell。在写入外存之后，原来内存中存储程序的部分就可以空闲出来了，但是我们并没有回收。

我们的页帧分配器采用堆栈式进行管理，因此我们可以将单独对应空闲出来的页帧放入其中，以进行回收。

> Recycle memory: 8022e000-80258000 (2A000)
> 
> Kernel memory: 80200000-0x802ea000 (EA000) with 0.5MB heap
>
> Optimization: 42/234 = 17.95%
>
> Optimization: 42/106 = 39.62% (no heap)


### 程序载入的内存消耗

读取ELF文件，载入的过程:

1. 完整导入：需要将整个执行程序完整导入到内存，才开始解析。
2. Double-copy： 导入到内存后，会占用相当于整个程序大小的内存，之后，还会专门为了建立程序，复制进memory set之中，还会出现一次复制。

意味着我们载入一个程序，需要两倍的内存，一倍的堆。堆采用的架构为伙伴系统，而当前的busybox大小约为1.6MB，意味着我们需要申请1.6MB的堆。伙伴系统在处理该情况时，需要拿出最小2MB的连续空间，这意味着我们需要分配4MB的空间，但是内核只有6MB可用空间（8MB-RustSBI 2MB），这显然不能够满足我们的内存现有容量的限制。

#### 基本优化想法

1. 不完整导入就没有办法使用elf解析，各个字段都不明晰。对于ELF解析我也不懂。
2. 最多只能优化到 one copy zero heap，这样我们需要直接copy到“内存的剩余空间之中”（也就是页帧），而不能直接使用buffer（来自堆）储存，只要用了堆我们就必须再copy一次到“内存的剩余空间之中”。

第二点意味着，我们需要直接copy进内存剩余空间中。但是页帧的分配并非连续。不连续的分配就不能够在不使用页表的情况进行ELF解析。

但是只要我们优化了第一点，即如果我们能够拆分ELF解析，一小段一小段的解析，我们就可以解析一部分就分配一部分页帧，这样近似于 two copy zero heap。但是我们ELF解析是调用的库，因此我们需要重写对应的函数，这存在一定的难度，并且不能够复用，我们希望一一种更优雅的方式来解决这个问题。

对于two copy zero heap，还可以使用使用动态增长堆的做法。只要堆能够动态增长，就没必要区分堆和内存区域了。但是实际上并非如此，堆的增长容易，回收难。这会造成内存使用量的增多。

#### kmmap：内核虚拟化（采用）

内核虚拟化，具体指的是，在内核地址空间进行虚实地址非恒等映射，将原本不连续的空间通过地址映射，以连续的虚地址访问。

这样，我们就可以不必从堆中申请空间，而是拿出一块连续的空间进行相应程序的数据存放。这实际上是页帧分配和动态堆的折中，既避免了动态堆难以回收的困境，又避免了将内核完全虚拟化的额外负担。同时，我们的实现复用了mmap的思想，还为内核虚拟化功能提供了对应的支持，这是我们所认为最佳的方法。

最终我们的优化结果
> two copy one heap: >6.5MB
> 
> two copy zero heap: 4.38MB
>
> Optimization: 2.12/6.5 = 32.6%
>

我们在其中遇到了一些问题，发现页表项的U标志为仅用户可用的意思。因此内核虚拟化的时候不能设置该标志位，否则出发load/store page fault。（一个凶险的bug+愚蠢的脑袋）

#### 页换入换出（未实现）

既然我们没有办法压缩到我们需要的内存大小，那么索性就进行内存换入换出。将内存换入到外存中，以页为单位。

基本思想：当无空闲页帧时，抽取一个已用页帧，将其页表项进行标记（已被换出，不可访问），然后将其换入到外存特定的文件中，文件以专有的数据结构进行管理。当出发page fault时，需要增加换出判断，如果是其造成的，就应该要将对应的页进行换入（无空闲页帧又会造成换出）。

这种方法会有额外的功能实现，牵扯到文件系统和内存管理单元，工程量较大，因此我们目前不准备实现。


#### lazy exec + direct access（未实现，搁置）

事实上，我们现在用的ELF加载库需要整个加载进来。我们的想法是，直接解析头文件库。

因此我们需要自己编写解析ELF文件的逻辑，这样，我们仅需要加载ELF header（64bits），之后根据ELF头加载Program Header，据此可以获得Program所在的位置和大小。然后就此打住，不必再继续读取。解析所有的LOAD program（还要加上ELF和program header），然后使用mmap映射至应该在的虚拟地址。这样，我们的lazy exec就完成了。

之后，我们还提出了更加激进的方案。mmap可以直接绕过文件系统，通过预留的蔟号直接读取相应的数据。这提供了新的优化思路，也就是说，文件系统单独提供对于确定的簇号进行数据读取的旁路，以对特定的情况进行优化。这与open channel SSD的思想有一定的相似之处（liblightnvm直接访问device driver），可以提供多种访问SSD的方式。

现在我们的方法已经能够解决一定程度上的内存短缺问题，如果我们激进的使用lazy的办法，会影响到所有程序的执行速度。因此我们暂时不准备实现，以空间换时间（注意lazy在exec会更快）。