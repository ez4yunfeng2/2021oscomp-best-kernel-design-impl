## UltraOS优化

### 初始进程内存回收

在评测系统下，任何自定义的程序都必须要放入在OS程序中一同打包，我们采用的策略是先放置于内存中，然后初始化写入至外存，再exec initproc，initproc会exec shell。在写入外存之后，原来内存中存储程序的部分就可以空闲出来了，但是我们并没有回收。

我们的页帧分配器采用堆栈式进行管理，因此我们可以将单独对应空闲出来的页帧放入其中，以进行回收。

> Recycle memory: 8022e000-80258000 (2A000)
> 
> Kernel memory: 80200000-0x8056a000 (36A000)
>
> Optimization: 42/874 = 4.81%


### 程序载入的内存消耗(未完成)

读取ELF文件，载入的过程:

1. 完整导入：需要将整个执行程序完整导入到内存，才开始解析。
2. Double-copy： 导入到内存后，会占用相当于整个程序大小的内存，之后，还会专门为了建立程序，复制进memory set之中，还会出现一次复制。

意味着我们载入一个程序，需要两倍的内存，一倍的堆。

#### 基本优化想法

1. 不完整导入就没有办法使用elf解析，各个字段都不明晰。对于ELF解析我也不懂。
2. 最多只能优化到 one copy zero heap，这样我们需要直接copy到“内存的剩余空间之中”（也就是页帧），而不能直接使用buffer（来自堆）储存，只要用了堆我们就必须再copy一次到“内存的剩余空间之中”。

第二点意味着，我们需要直接copy进内存剩余空间中。但是页帧的分配并非连续，据我观察heap一次要了1MB大小，也就是256个page。不连续的分配就不能够在不使用页表的情况进行ELF解析。

但是只要我们优化了第一点，即如果我们能够拆分ELF解析，一小段一小段的解析，我们就可以解析一部分就分配一部分页帧，这样近似于 two copy zero heap。

对于two copy zero heap，还可以使用使用动态增长堆的做法。只要堆能够动态增长，就没必要区分堆和内存区域了。但是实际上并非如此，堆的增长容易，回收难。这会造成内存使用量的增多。