### 信号机制

本部分属于kernel中进程控制模块的信号机制。

信号也称为软中断的模拟机制，但是这并不是软中断。根据所查资料显示，系统调用等来自cpu内部程序已经设计好的确定的中断才是软件中断，但是那些来自cpu外围的需要中途打断程序的是硬中断。

信号的机制主要分为三种：信号的产生，信号的注册与注销、信号的执行。

#### 信号的产生

##### 什么是信号

信号分为实时信号（可信信号）和非实时信号（不可信信号）。一共有三十二种信号，标号为0-31，32-63是这三十二种的重复，只不过为实时信号。

Linux支持的信号列表如下。很多信号是与机器的体系结构相关的

信号值 默认处理动作 发出信号的原因

SIGHUP 1 A 终端挂起或者控制进程终止

SIGINT 2 A 键盘中断（如break键被按下）

SIGQUIT 3 C 键盘的退出键被按下

SIGILL 4 C 非法指令

SIGABRT 6 C 由abort(3)发出的退出指令

SIGFPE 8 C 浮点异常

SIGKILL 9 AEF Kill信号

SIGSEGV 11 C 无效的内存引用

SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道

SIGALRM 14 A 由alarm(2)发出的信号

SIGTERM 15 A 终止信号

SIGUSR1 30,10,16 A 用户自定义信号1

SIGUSR2 31,12,17 A 用户自定义信号2

SIGCHLD 20,17,18 B 子进程结束信号

SIGCONT 19,18,25 进程继续（曾被停止的进程）

SIGSTOP 17,19,23 DEF 终止进程

SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键

SIGTTIN 21,21,26 D 后台进程企图从控制终端读

SIGTTOU 22,22,27 D 后台进程企图从控制终端写

 

处理动作一项中的字母含义如下

A 缺省的动作是终止进程

B 缺省的动作是忽略此信号，将该信号丢弃，不做处理

C 缺省的动作是终止进程并进行内核映像转储（dump core），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。

D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）

E 信号不能被捕获

F 信号不能被忽略


##### 如何存储信号

Linux采用的是bit位进行信号的标志，但是我们采用的是队列。如果信号到达了，就放入队列之中，队列中标识了信号(bitflags(usize))的数值。我们与linux保持一致，优先处理信号量最大的操作。因此，我们使用优先队列来做相应的操作。

signal_pending: BinaryHeap<Signals>

#### 信号的注册与注销

这是为了更改对应信号的处理逻辑，为用途提供定制化需求。

信号的注册又叫信号的安装（Installation），通常调用的syscall为rt_sigaction。

##### 如何注册

int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));

该方法将信号进行注册，一共有32个信号。为了能够迅速定位到对应的信号处理函数，我们可以设置一个32项的数组，对应32个信号的处理函数先设置为默认值。但是这会增大PCB的大小，因此我们采取HashMap，注册的时候就加入，寻找的时候直接以信号量为键值寻找即可。

> SigHandler = BTreeMap::new()
