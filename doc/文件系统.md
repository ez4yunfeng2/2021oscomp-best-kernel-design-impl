

## 工作计划

| 时间      | 内容                           | 完成情况                     |
| --------- | ------------------------------ | ---------------------------- |
| 3.22-3.25 | 完成架构设计，确定要实现的方法 | 基本完成，细节靠开发过程发现 |
|           |                                |                              |
|           |                                |                              |
|           |                                |                              |

代码标记

TODO 待完成

QUES 存在疑问

DEBUG 待调试

## 基本概念

### 软硬链接

软链接就是快捷方式

硬链接相当于是对文件的多个引用

删除硬链接，引用数量减一

删除原始文件，软连接失效，硬连接引用数量减一

软连接或者硬连接都可以修改原始文件



## rCore-Tutorial-v3的EFS

### 概述

通过easy-fs-fuse的easy_fs_pack创建文件

格式化为efs，并将应用的elf文件写入

easy_fs_pack中使用到clap包，用于获取命令行输入的参数

```rust
fn easy_fs_pack() -> std::io::Result<()> {
    // clap::matches 用于捕获用户输入的参数. 在makefile中，命令为:
    // @cd ../easy-fs-fuse && cargo run --release \
    // -- -s ../user/src/bin/ \
    // -t ../user/target/riscv64gc-unknown-none-elf/release/
    // 因此得到的参数就是两个路径
    let matches = App::new("EasyFileSystem packer")
        .arg(Arg::with_name("source")
            .short("s") // 对应输入的 -s
            .long("source")//对应输入 --source
            .takes_value(true)
            .help("Executable source dir(with backslash)")
        )
        .arg(Arg::with_name("target")
            .short("t")
            .long("target")
            .takes_value(true)
            .help("Executable target dir(with backslash)")    
        )
        .get_matches();
    let src_path = matches.value_of("source").unwrap();
    let target_path = matches.value_of("target").unwrap();
    println!("src_path = {}\ntarget_path = {}", src_path, target_path);
    // ...
```

### 启动

main中调用 fs::list_apps();时

ROOT_INODE被创建

```rust
lazy_static! {
    // 通过ROOT_INODE可以实现对efs的操作
    pub static ref ROOT_INODE: Arc<Inode> = {
        // 此处载入文件系统
        let efs = EasyFileSystem::open(BLOCK_DEVICE.clone());
        Arc::new(EasyFileSystem::root_inode(&efs))
    };
}
// 然后BLOCK_DEVICE被创建
lazy_static! {
    pub static ref BLOCK_DEVICE: Arc<dyn BlockDevice> = Arc::new(BlockDeviceImpl::new());
}

// 根据平台不同，BlockDeviceImpl为VirtIOBlock(for qemu)或SDCardWrapper


```

### 分层

| 层级 (low to high) | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 块设备接口         | 一个提供给块设备的trait，SDCardWrapper实现了该特性           |
| 块缓存层           | 对外提供get_block_cache接口，会自动向设备读取/写回/替换块    |
| 磁盘数据结构层     | 磁盘布局、超级块、DiskInode、位图等。就是磁盘实际存储的数据结构。是对文件最底层的操作（文件概念出现的最底层）。 |
| 磁盘块管理器层     | 对磁盘布局的一种抽象，也可以说是文件系统布局的顶层(对象：EasyFileSystem)。可以创建、打开文件系统，控制数据块和inode的分配/回收，因此主要是为vfs，即索引节点层提供服务的。 |
| 索引节点层(vfs.rs) | 主体对象为inode，文件系统顶层，这里是真正意义上为系统提供了文件操作的接口，比如文件的搜索、创建、读写、清空 |
|                    | 以下为OS内核                                                 |
| inode.rs           | 主体对象为OSInode，实际就是内核对文件操作的载体，其实现了File trait。每个进程控制块内存放的文件描述符对应一个打开文件的OSInode的引用（fd_table）。 |

### 已实现提供给内核的接口

| 方法                        | 简述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| pipe/make_pipe              |                                                              |
| Stdin/Stdout的r/w           |                                                              |
| OSInode::File trait         |                                                              |
| OSInode::read_all           | 读取文件所有内容                                             |
| open_file                   |                                                              |
| list_apps                   | 通过inode::ls实现                                            |
| OpenFlags::read_write       | 是否可读可写，但是**文件权限没有实现**                       |
| dirent                      | 当前的目录项增加**仅仅采用了在后方追加的策略**，**没有实现移除**。如果删除时直接移除，会产生空间的浪费，目前的追加算法就不可取（算法为：根据数目计算偏移量，这样的算法会在有空缺目录项的情况下覆盖已有目录）。 |
|                             |                                                              |
| 下面为文件系统的方法        |                                                              |
| inode :: find               | 根据文件名                                                   |
| inode :: create             |                                                              |
| inode :: ls                 | **并没有判断是否是目录**                                     |
| inode :: read_at / write_at |                                                              |
| inode :: clear              | 仅仅是把数据清空，**没有回收Inode**                          |

```rust
//OSInode
pub struct OSInode {
    readable: bool,
    writable: bool,
    inner: Mutex<OSInodeInner>,
}

pub struct OSInodeInner {
    offset: usize, // 当前读写的位置
    inode: Arc<Inode>, // inode引用
}

```



## FS for UltraOS

计划实现的内容（不包括efs已经实现的内容）

| 方法（提供给内核）           | 简述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 扩展inode :: create的功能    | 可以选择创建文件或目录                                       |
| find_path                    | 需要更新为可以递归搜索目录，把中间目录全部返回，由OSInode层负责压栈 |
| rm                           | 包括目录项管理、Inode回收等                                  |
| 实现权限（待定）             |                                                              |
| 完善ls的健壮性               |                                                              |
| 目录管理/目录项管理          | 需要修改原有的目录项增删管理                                 |
| {layout, vfs}::decrease_size | 减小文件大小，现在只有增大。。。因为dirent删除后产生空位，   |
| mmap：应当在栈之上？         |                                                              |
|                              |                                                              |
|                              |                                                              |

### 目录设计

layout提供的方法，以及vfs原有的写法，为目录的增加提供了很大的便利

#### 背景

​		存在疑问：后续是否支持多个shell？

​		内核当前仅挂载根目录，为了实现多级目录、切换当前工作目录的功能，将**ROOT_INODE**更改为**CURRENT_INODE** 。

cd命令主要有以下用法：

```shell
cd a/b  //从当前目录往下
cd /a/b/c  //从根目录开始往下，绝对路径
cd .
cd ..
cd ~   //返回Home
cd     //返回Home
```

#### 目录栈		

​		首先需要修改目录的内容，除了不同文件/目录的dirent，还应包括./.. 两个目录，根目录的 .. 指向自己。但是这样每次使用..或者.都要调用文件系统的方法，效率不高。因此决定暂时按照文件系统实验时我的做法，维护一个目录栈于OSInode层，存放各级目录的inode。

​		例如，若当前目录为 /a/b/c/d，那么栈底为 / ，栈顶为d，即CURRENT_INODE。栈中维护对inode的强引用，CURRENT_INODE则可以是弱引用。这样一旦输入的路径包含 .. ，就需要pop。一旦inode从栈中弹出，就会结束生命周期并被释放。这种实现方法所用的数据结构都在内存中，因此无需访问磁盘，也不必访问磁盘缓存（虽然是磁盘缓存，但在块内寻址还是需要较大的代价），同时符合局部性原理（可能会在当前目录的上下级来回切）。这样的实现也存在缺点，比如增加了fs和os的耦合性。

​		对于shell的cd实现，也可以运用一个目录栈，但是只需存储String即可。每次根据系统调用后内核返回的是否切换目录成功，决定是否修改栈，修改栈内容也仅需根据用户输入的字符串。这样做的好处是减少了内核和用户之间的数据传输，增加效率，同时减少耦合。

​		但是并不支持多个shell。。

#### 适合扩展的方案

每当创建目录的时候，默认创建 . 和 .. 两个目录项

**李老板的方案**：返回inode_id，每次切换直接传入用户的路径和inode_id。		

可行！创建vfs::Inode无需取出磁盘块，因此代价不高。只需修改EFS::root_inode为创建任意的Inode即可。

切换到目标目录后，也没必要将其对应的数据块读出！

因此也没必要维护一个Inode栈？是的

​		当前的OSInode/Inode很好获取，只需少量的计算。

​		代价真正大的地方在于切换，因为需要读取当前inode对应的目录，这就会访问数据块

​		如果目录里面有cd ..或者cd .，那么必须将当前目录的数据块取出

​		不过一般情况下，切换到某个目录后会对其操作，目录所在数据块会被缓存

​		综上，使用目录栈唯一显著有效的情况为：进入了某个目录，然后cd ..

​		但谁会这么操作呢？

此外，有一种写法：

```shell
ghc@ghc-virtual-machine:~/桌面/os_comp/rv64_os$ cd rCore-Tutorial-v3/./os/
ghc@ghc-virtual-machine:~/桌面/os_comp/rv64_os/rCore-Tutorial-v3/os$ 
```

这也从某种层面肯定了设置 . 和 .. 目录项的科学性



**另一个方案**：将目录作为文件打开？和open一样，返回OSInode。

传参也需要代价，还不如只传一个inode_id



#### 方法定义

```rust
//***** 磁盘块管理器层efs *****
// 修改根目录的创建，添加.和..(finish)
EasyFileSystem::create(...)->...

//***** 索引节点层vfs *****
// 新建文件/目录（finish）
// 仅支持当前inode，不支持搜索
Inode::create(name: &str, type: DiskInodeType) -> Option<Arc<Inode>>

// 根据目录查找，可以调用find一级级找（finish）
Inode::find_path(&self, path: Vec<&str>) -> Option<Arc<Inode>>

// 功能同find_path，但返回一个Vec<Arc<inode>>（finish）
// 这样的设计似乎比较恶心。。
Inode::ch_dir() -> Option<Vec<Arc<inode>>>

//***** OSInode *****
// 修改为按路径打开(finish)
open_file(inode_id: u32, path: &str)->Option<Arc<OSInode>>

// 往后读一个目录
read_dir(inode_id: u32, )->Option<Arc<?>>

// 切换工作目录(finish)
ch_dir(inode_id: u32, path: Vec<&str>)->i32
```



### 文件删除

#### 目录项管理

​		当前的目录项增加仅仅采用了在后方追加的策略，且没有实现移除功能。如果删除文件时直接移除，会产生空间的浪费，目前的追加算法不可取（算法为：根据已有目录数目计算追加目录所在偏移量，这样的算法会在有空缺目录项的情况下，导致新增目录项覆盖已有目录项）。但如果从头搜索空闲目录项，代价可能非常大。

​		**设计新的算法：每当删除一个目录项，就将排在最后的目录项补到被删除目录项的位置，追加的时候依然根据原来的算法**

​		具体过程为，将最后一个目录项覆盖要删除的目录项，然后删除最后一个目录项

​		当只有一个目录项的时候不需要，通过大小即可判断

##### 性能分析

​		如果目录项集中在一个块，那么效率是显然的，但如果占有多个块，那么存在一定的问题：**正常情况下删除只需取出一个数据块，但是这种情况下需要取出两个**，因为被删除的目录项和最后一个目录项可能在不同的块。但实际上，如果采用传统的遍历策略，插入时依然需要取出两个块，而使用这种方法插入目录项时，仅需取出一个数据块。一般情况下创建目录比较多，因此效率还是客观的。

​		当前inode的块索引构成为：28直接 + 1一阶 + 1二阶，文件大小超过8MB

​		有一种解决方案：将一个直接索引改为插入位置insert_pos，这样每删除一个文件，就把insert_pos改为被删文件目录项位置。如果连续删两个就会出事情，因此保留设计的算法。

​		**有一点需要注意，如果删除整个目录**，比如删除/a/b，那么还是要遍历b的所有目录项以删除其全部子目录/文件，最后将数据块清空，然后对a的目录执行我们的算法。



#### Inode管理

​		删除文件时，Inode的内容需要清空，同时也要回收Inode

​		实际上，DiskInode在初始化的时候会进行清零，因此在删除时无需对其清空，只要修改位图即可

#### 数据块回收

和数据块匹配一样，遍历inode的索引并回收

#### 方法定义

```rust
//***** 磁盘块管理层efs *****
// 回收inode
pub fn dealloc_inode(&nut self, inode_id: u32)

//***** 索引节点层vfs (Inode) *****
// 删除文件/目录
pub fn remove(&self, path: Vec<&str>, type: DiskInodeType) -> bool
// 删除Inode对应的文件
fn remove_file(&self) -> bool
// 递归删除Inode对应的目录
fn remove_dir(&self) -> bool

//***** OSInode *****
pun fn remove(path: Vec<&str>, type: DiskInodeType) -> bool
```

#### 文件缩小

如何确定文件修改后的大小是一个问题。

实际上，文件中其实没有EOF这个东西。

C语言确实也没有提供删除文件内容的库。

在网上查阅资料，发现删除指定的内容时，一般是建立一个临时文件，然后把原文件的内容写入，跳过要删除的内容。

所以暂时不管。



### 用户端

DIR dirent

```c
struct dirent   
{   
　　long d_ino; /* inode number 索引节点号 */  
　　   
    off_t d_off; /* offset to this dirent 在目录文件中的偏移 */  
　　   
    unsigned short d_reclen; /* length of this d_name 文件名长 */  
　　   
    unsigned char d_type; /* the type of d_name 文件类型 */  
　　   
    char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */  
}  

struct __dirstream   
{   
    void *__fd;    
    char *__data;    
    int __entry_data;    
    char *__ptr;    
    int __entry_ptr;    
    size_t __allocation;    
    size_t __size;    
    __libc_lock_define (, __lock)    
};   
  
```



### 优化

真正的优化：减少数据块的读写

虚假的优化：死扣算法



### temp

目前传入的name都是&str，需要大规模改为path: Vec<&str>

![image-20210323222145846](C:\Users\Eobard\AppData\Roaming\Typora\typora-user-images\image-20210323222145846.png)