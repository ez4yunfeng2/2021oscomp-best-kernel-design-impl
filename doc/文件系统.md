

## 工作计划

| 时间      | 内容                           | 完成情况                     |
| --------- | ------------------------------ | ---------------------------- |
| 3.22-3.25 | 完成架构设计，确定要实现的方法 | 基本完成，细节靠开发过程发现 |
| 4.10      | 完成并发访问设计与测试         |                              |
|           |                                |                              |
|           |                                |                              |

代码标记

TODO 待完成

QUES 存在疑问

DEBUG 待调试

## 基本概念

### 软硬链接

软链接就是快捷方式

硬链接相当于是对文件的多个引用

删除硬链接，引用数量减一

删除原始文件，软连接失效，硬连接引用数量减一

软连接或者硬连接都可以修改原始文件

### linux相关

#### open/fopen

linux中对文件操作主要是两种方法：open/fopen (先不管mmap)

操作的对象分别是fd、FILE*

open来自unistd.h库，符合POSIX，是系统调用

fopen则是C语言的库函数，其实现依赖于open

##### open

Linux的task_struct如下：

```c
struct task_struct {
	......
/* filesystem information */
	struct fs_struct *fs;
/* open file information */
	struct files_struct *files;
	......
};

struct files_struct {
  /*
   * read mostly part
   */
	atomic_t count;
	struct fdtable __rcu *fdt;
	struct fdtable fdtab;
  /*
   * written part on a separate cache line in SMP
   */
	spinlock_t file_lock ____cacheline_aligned_in_smp;
	int next_fd;
	struct embedded_fd_set close_on_exec_init;
	struct embedded_fd_set open_fds_init;
	struct file __rcu * fd_array[NR_OPEN_DEFAULT]; //进程级打开文件描述符表
};

```

其中files_struct内包含了进程打开的文件描述符表 fd_array，其内容为指向file的指针

file的结构就比较复杂，包含了很多信息(包括inode、dentry)，其与OSInode对应（或者可以认为更高一层）

可见内核还是对进程打开的文件进行了存储

##### fopen

fopen会在用户态实现缓存，FILE*里面就是缓存的一系列指针

stdin/stdout实际上也是FILE*

因此，我们可以在现有open/read/write的基础上，实现fopen/fread/fwrite等用户库



[fopen/open的区别]: http://blog.chinaunix.net/uid-29025972-id-3847404.html
[文件描述符的理解]: https://blog.csdn.net/qq_28114615/article/details/94590598



## rCore-Tutorial-v3的EFS

### 概述

通过easy-fs-fuse的easy_fs_pack创建文件

格式化为efs，并将应用的elf文件写入

easy_fs_pack中使用到clap包，用于获取命令行输入的参数

```rust
fn easy_fs_pack() -> std::io::Result<()> {
    // clap::matches 用于捕获用户输入的参数. 在makefile中，命令为:
    // @cd ../easy-fs-fuse && cargo run --release \
    // -- -s ../user/src/bin/ \
    // -t ../user/target/riscv64gc-unknown-none-elf/release/
    // 因此得到的参数就是两个路径
    let matches = App::new("EasyFileSystem packer")
        .arg(Arg::with_name("source")
            .short("s") // 对应输入的 -s
            .long("source")//对应输入 --source
            .takes_value(true)
            .help("Executable source dir(with backslash)")
        )
        .arg(Arg::with_name("target")
            .short("t")
            .long("target")
            .takes_value(true)
            .help("Executable target dir(with backslash)")    
        )
        .get_matches();
    let src_path = matches.value_of("source").unwrap();
    let target_path = matches.value_of("target").unwrap();
    println!("src_path = {}\ntarget_path = {}", src_path, target_path);
    // ...
```

### 启动

main中调用 fs::list_apps();时

ROOT_INODE被创建

```rust
lazy_static! {
    // 通过ROOT_INODE可以实现对efs的操作
    pub static ref ROOT_INODE: Arc<Inode> = {
        // 此处载入文件系统
        let efs = EasyFileSystem::open(BLOCK_DEVICE.clone());
        Arc::new(EasyFileSystem::root_inode(&efs))
    };
}
// 然后BLOCK_DEVICE被创建
lazy_static! {
    pub static ref BLOCK_DEVICE: Arc<dyn BlockDevice> = Arc::new(BlockDeviceImpl::new());
}

// 根据平台不同，BlockDeviceImpl为VirtIOBlock(for qemu)或SDCardWrapper


```

### 分层

| 层级 (low to high) | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 块设备接口         | 一个提供给块设备的trait，SDCardWrapper实现了该特性           |
| 块缓存层           | 对外提供get_block_cache接口，会自动向设备读取/写回/替换块    |
| 磁盘数据结构层     | 磁盘布局、超级块、DiskInode、位图等。就是磁盘实际存储的数据结构。是对文件最底层的操作（文件概念出现的最底层）。 |
| 磁盘块管理器层     | 对磁盘布局的一种抽象，也可以说是文件系统布局的顶层(对象：EasyFileSystem)。可以创建、打开文件系统，控制数据块和inode的分配/回收，因此主要是为vfs，即索引节点层提供服务的。 |
| 索引节点层(vfs.rs) | 主体对象为inode，文件系统顶层，这里是真正意义上为系统提供了文件操作的接口，比如文件的搜索、创建、读写、清空 |
|                    | 以下为OS内核                                                 |
| inode.rs           | 主体对象为OSInode，实际就是内核对文件操作的载体，其实现了File trait。每个进程控制块内存放的文件描述符对应一个打开文件的OSInode的引用（fd_table）。 |

### 已实现提供给内核的接口

| 方法                        | 简述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| pipe/make_pipe              |                                                              |
| Stdin/Stdout的r/w           |                                                              |
| OSInode::File trait         |                                                              |
| OSInode::read_all           | 读取文件所有内容                                             |
| open_file                   |                                                              |
| list_apps                   | 通过inode::ls实现                                            |
| OpenFlags::read_write       | 是否可读可写，但是**文件权限没有实现**                       |
| dirent                      | 当前的目录项增加**仅仅采用了在后方追加的策略**，**没有实现移除**。如果删除时直接移除，会产生空间的浪费，目前的追加算法就不可取（算法为：根据数目计算偏移量，这样的算法会在有空缺目录项的情况下覆盖已有目录）。 |
|                             |                                                              |
| 下面为文件系统的方法        |                                                              |
| inode :: find               | 根据文件名                                                   |
| inode :: create             |                                                              |
| inode :: ls                 | **并没有判断是否是目录**                                     |
| inode :: read_at / write_at |                                                              |
| inode :: clear              | 仅仅是把数据清空，**没有回收Inode**                          |

```rust
//OSInode
pub struct OSInode {
    readable: bool,
    writable: bool,
    inner: Mutex<OSInodeInner>,
}

pub struct OSInodeInner {
    offset: usize, // 当前读写的位置
    inode: Arc<Inode>, // inode引用
}

```



## FS for UltraOS

计划实现的内容（不包括efs已经实现的内容）

| 方法（提供给内核）           | 简述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 扩展inode :: create的功能    | 可以选择创建文件或目录                                       |
| find_path                    | 需要更新为可以递归搜索目录，把中间目录全部返回，由OSInode层负责压栈 |
| rm                           | 包括目录项管理、Inode回收等                                  |
| 实现权限（待定）             |                                                              |
| 完善ls的健壮性               |                                                              |
| 目录管理/目录项管理          | 需要修改原有的目录项增删管理                                 |
| {layout, vfs}::decrease_size | 减小文件大小，现在只有增大。。。因为dirent删除后产生空位，   |
| mmap：应当在栈之上？         |                                                              |
|                              |                                                              |
|                              |                                                              |

### FAT32

[FAT32介绍]: https://blog.csdn.net/u010650845/article/details/60881687?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-4.control&amp;dist_request_id=1331973.7587.16185600288003081&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-4.control

#### 对齐问题

​		k210在内存访问上有着较为严格的对齐要求。对齐取决于定义的类型，如u32就要对齐32位，u64对齐64位。

但是FAT32的一些字段是不对齐的，例如有从0x0B开始的u16。因此读入时需要进行处理，而不能像ext2那样与结构体直接映射。

​		为解决该问题，读入的时候简单以字节buffer的形式读入，通过移位等运算获取信息。因为BPB块只需要读，而且大多信息对我们没有用处，因此只需把必要的信息一次读入，常驻内存。但是给出的结构体也很好用, 可以用于从buffer获取数据

​		rust使用\#[repr(packed)]限制结构体非对齐

​		有些字段需要写入，定义具有针对性的接口，往指定的扇区+offset写

#### 重要字段

##### BIOS Parameter Block（0号扇区）

| Offset (decimal) | Offset (hex) | Size (in bytes) | Meaning                                                      |
| ---------------- | ------------ | --------------- | ------------------------------------------------------------ |
| 11               | 0x0B         | 2               | The number of Bytes per sector (remember, all numbers are in the little-endian format). |
| 13               | 0x0D         | 1               | Number of sectors per cluster.                               |
| 14               | 0x0E         | 2               | Number of reserved sectors. The boot record sectors are included in this value.（可以确定FAT表的位置） |
| 16               | 0x10         | 1               | Number of File Allocation Tables (FAT's) on the storage media. Often this value is 2. |
| 17               | 0x11         | 2               | Number of directory entries (must be set so that the root directory occupies entire sectors). |
| 19               | 0x13         | 2               | The total sectors in the logical volume. If this value is 0, it means there are more than 65535 sectors in the volume, and the actual count is stored in the Large Sector Count entry at 0x20. |
| 28               | 0x1C         | 4               | Number of hidden sectors. (i.e. the LBA of the beginning of the partition.) |
| 32               | 0x20         | 4               | Large sector count. This field is set if there are more than 65535 sectors in the volume, resulting in a value which does not fit in the *Number of Sectors* entry at 0x13. |

##### Extended Boot Record（紧随其后）

| Offset (decimal) | Offset (hexadecimal) | Length (in bytes) | Meaning                                                      |
| ---------------- | -------------------- | ----------------- | ------------------------------------------------------------ |
| 36               | 0x024                | 4                 | Sectors per FAT. The size of the FAT in sectors.（FAT表扇区数，第二个FAT表的位置可以由此计算） |
| 44               | 0x02C                | 4                 | The cluster number of the root directory. Often this field is set to 2. |
| 48               | 0x030                | 2                 | The sector number of the FSInfo structure.                   |
| 50               | 0x032                | 2                 | The sector number of the backup boot sector.                 |
| 510              | 0x1FE                | 2                 | Bootable partition signature 0xAA55.                         |

##### FSInfo Structure (FAT32 only)

| Offset (decimal) | Offset (hexadecimal) | Length (in bytes) | Meaning                                                      |
| ---------------- | -------------------- | ----------------- | ------------------------------------------------------------ |
| 0                | 0x0                  | 4                 | Lead signature (must be 0x41615252 to indicate a valid FSInfo structure) |
| 484              | 0x1E4                | 4                 | Another signature (must be 0x61417272)                       |
| 488              | 0x1E8                | 4                 | Contains the last known free cluster count on the volume. If the value is 0xFFFFFFFF, then the free count is unknown and must be computed. However, this value might be incorrect and should at least be range checked (<= volume cluster count) |
| 492              | 0x1EC                | 4                 | Indicates the cluster number at which the filesystem driver should start looking for available clusters. If the value is 0xFFFFFFFF, then there is no hint and the driver should start searching at 2. Typically this value is set to the last allocated cluster number. As the previous field, this value should be range checked. |
| 508              | 0x1FC                | 4                 | Trail signature (0xAA550000)                                 |

#### 文件分配表

FAT32使用了32位中的28位，最高四位为保留，需要忽略

需要注意的是，FAT可能非常非常大，将其常驻内存不是明智的选择，但是可以缓存几个扇区。

示例代码

```c
unsigned char FAT_table[sector_size];
unsigned int fat_offset = active_cluster * 4;
unsigned int fat_sector = first_fat_sector + (fat_offset / sector_size);
unsigned int ent_offset = fat_offset % sector_size;
 
//at this point you need to read from sector "fat_sector" on the disk into "FAT_table".
 
//remember to ignore the high 4 bits.
unsigned int table_value = *(unsigned int*)&FAT_table[ent_offset] & 0x0FFFFFFF;
 
//the variable "table_value" now has the information you need about the next cluster in the chain.
```

#### 校验与损坏检测

FAT表中，标记为0x0FFFFFF7表示簇有问题

FSInfo有两个签名0x52526141和0x72724161



#### 目录

##### 基本信息

​		FAT32的目录项分为长文件名和短文件名两种，长度均为32B。

​		需要注意的是，长文件名编码为unicode，短文件名则为ascii（有毒

​		长文件名的目录项还要有对11位短文件名的校验和

​		长文件名以0xFF填充空缺，段文件用0x20填充

​		目录项首为0xE5时表示删除

##### 文件类型

​		不论是长短目录项，都有一个attribute字段。有以下的标志可取：

​		READ_ONLY=0x01 HIDDEN=0x02 SYSTEM=0x04 VOLUME_ID=0x08 DIRECTORY=0x10 ARCHIVE=0x20 		

​		LFN=READ_ONLY|HIDDEN|SYSTEM|VOLUME_ID

​		LFN=0x0F，表示目录项为长文件名，其余则用于判断文件/目录和读写权限

##### 长文件名目录项		

​		长文件名目录项的第一个字段为order，用于表示使用多个目录项时的顺序。

​		如果oder的第无位为1，即顺序与0x40求或，则为最后一个长名目录项

​		长文件名的目录项可以由多个目录项拼接而成，以倒序布局于磁盘，同时也要分配一个短文件名紧随其后。例如文件abcdefghijklmnopq.txt的目录项布局为

| 此处为低地址  |
| ------------- |
| nopq.txt      |
| abcdefghijklm |
| abcdef~1 txt  |
| 此处为高地址  |

​		






### 缓存设计
#### 多路缓存

​		Ultra OS的文件系统采用了多缓存的设计，让缓存更具针对性。整体上，FAT32经常操作的数据可以分为info扇区、FAT表、目录项、数据块四个部分，因此我们也将缓存划分为四种，合计缓存20个块（20*512 = 10KB）。
​		其中，info扇区有效的字段很少，但为了读写方便，还是将其作为一个块缓存。
​		FAT表实际上可以非常大，因此不宜全部放内存。实际上，一个扇区就足以存放128个簇号，因此就比赛而言，一个缓存块就足矣，但是为了通用性，使用两个块存放。FAT文件系统使用2个FAT，其中一个作备份用，因此对两个FAT的更新都需要同步。因此，我们采用纠缠缓存设计，共计缓存4个块，每个FAT分别两个块，且两个FAT被缓存的块是一一对应的。

​		目前还剩余15个块。FAT32中目录实际上代表了文件，它涵盖文件的所有信息，大小为32B，即一个块可以包含16个目录项（长文件名的情况会少一些），使用3个块缓存。最后，文件数据则使用12个块缓存。

#### 简化版多路缓存以及锁机制		

​		经过反思，这样的设计不是很可行，一是不方便替换，二是不能按需分配，占用空间大，三十结构复杂，查找效率不高。最后决定保留两个缓存，一个用于存放检索信息，另一个用于存储数据，并采用spin::RwLock进行加锁

​		






#### 锁机制



### 目录设计

layout提供的方法，以及vfs原有的写法，为目录的增加提供了很大的便利

#### 背景

​		存在疑问：后续是否支持多个shell？

​		内核当前仅挂载根目录，为了实现多级目录、切换当前工作目录的功能，将**ROOT_INODE**更改为**CURRENT_INODE** 。

cd命令主要有以下用法：

```shell
cd a/b  //从当前目录往下
cd /a/b/c  //从根目录开始往下，绝对路径
cd .
cd ..
cd ~   //返回Home
cd     //返回Home
```

#### 目录栈		

​		首先需要修改目录的内容，除了不同文件/目录的dirent，还应包括./.. 两个目录，根目录的 .. 指向自己。但是这样每次使用..或者.都要调用文件系统的方法，效率不高。因此决定暂时按照文件系统实验时我的做法，维护一个目录栈于OSInode层，存放各级目录的inode。

​		例如，若当前目录为 /a/b/c/d，那么栈底为 / ，栈顶为d，即CURRENT_INODE。栈中维护对inode的强引用，CURRENT_INODE则可以是弱引用。这样一旦输入的路径包含 .. ，就需要pop。一旦inode从栈中弹出，就会结束生命周期并被释放。这种实现方法所用的数据结构都在内存中，因此无需访问磁盘，也不必访问磁盘缓存（虽然是磁盘缓存，但在块内寻址还是需要较大的代价），同时符合局部性原理（可能会在当前目录的上下级来回切）。这样的实现也存在缺点，比如增加了fs和os的耦合性。

​		对于shell的cd实现，也可以运用一个目录栈，但是只需存储String即可。每次根据系统调用后内核返回的是否切换目录成功，决定是否修改栈，修改栈内容也仅需根据用户输入的字符串。这样做的好处是减少了内核和用户之间的数据传输，增加效率，同时减少耦合。

​		但是并不支持多个shell。。

#### 适合扩展的方案

每当创建目录的时候，默认创建 . 和 .. 两个目录项

**李老板的方案**：返回inode_id，每次切换直接传入用户的路径和inode_id。		

可行！创建vfs::Inode无需取出磁盘块，因此代价不高。只需修改EFS::root_inode为创建任意的Inode即可。

切换到目标目录后，也没必要将其对应的数据块读出！

因此也没必要维护一个Inode栈？是的

​		当前的OSInode/Inode很好获取，只需少量的计算。

​		代价真正大的地方在于切换，因为需要读取当前inode对应的目录，这就会访问数据块

​		如果目录里面有cd ..或者cd .，那么必须将当前目录的数据块取出

​		不过一般情况下，切换到某个目录后会对其操作，目录所在数据块会被缓存

​		综上，使用目录栈唯一显著有效的情况为：进入了某个目录，然后cd ..

​		但谁会这么操作呢？

此外，有一种写法：

```shell
ghc@ghc-virtual-machine:~/桌面/os_comp/rv64_os$ cd rCore-Tutorial-v3/./os/
ghc@ghc-virtual-machine:~/桌面/os_comp/rv64_os/rCore-Tutorial-v3/os$ 
```

这也从某种层面肯定了设置 . 和 .. 目录项的科学性



**另一个方案**：将目录作为文件打开？和open一样，返回OSInode。

传参也需要代价，还不如只传一个inode_id



#### 方法定义

```rust
//***** 磁盘块管理器层efs *****
// 修改根目录的创建，添加.和..(finish)
EasyFileSystem::create(...)->...

//***** 索引节点层vfs *****
// 新建文件/目录（finish）
// 仅支持当前inode，不支持搜索
Inode::create(name: &str, type: DiskInodeType) -> Option<Arc<Inode>>

// 根据目录查找，可以调用find一级级找（finish）
Inode::find_path(&self, path: Vec<&str>) -> Option<Arc<Inode>>

// 功能同find_path，但返回一个Vec<Arc<inode>>（finish）
// 这样的设计似乎比较恶心。。
Inode::ch_dir() -> Option<Vec<Arc<inode>>>

//***** OSInode *****
// 修改为按路径打开(finish)
open_file(inode_id: u32, path: &str)->Option<Arc<OSInode>>

// 往后读一个目录
read_dir(inode_id: u32, )->Option<Arc<?>>

// 切换工作目录(finish)
ch_dir(inode_id: u32, path: Vec<&str>)->i32
```



### 文件删除

#### 目录项管理

​		当前的目录项增加仅仅采用了在后方追加的策略，且没有实现移除功能。如果删除文件时直接移除，会产生空间的浪费，目前的追加算法不可取（算法为：根据已有目录数目计算追加目录所在偏移量，这样的算法会在有空缺目录项的情况下，导致新增目录项覆盖已有目录项）。但如果从头搜索空闲目录项，代价可能非常大。

​		**设计新的算法：每当删除一个目录项，就将排在最后的目录项补到被删除目录项的位置，追加的时候依然根据原来的算法**

​		具体过程为，将最后一个目录项覆盖要删除的目录项，然后删除最后一个目录项

​		当只有一个目录项的时候不需要，通过大小即可判断

##### 性能分析

​		如果目录项集中在一个块，那么效率是显然的，但如果占有多个块，那么存在一定的问题：**正常情况下删除只需取出一个数据块，但是这种情况下需要取出两个**，因为被删除的目录项和最后一个目录项可能在不同的块。但实际上，如果采用传统的遍历策略，插入时依然需要取出两个块，而使用这种方法插入目录项时，仅需取出一个数据块。一般情况下创建目录比较多，因此效率还是客观的。

​		当前inode的块索引构成为：28直接 + 1一阶 + 1二阶，文件大小超过8MB

​		有一种解决方案：将一个直接索引改为插入位置insert_pos，这样每删除一个文件，就把insert_pos改为被删文件目录项位置。如果连续删两个就会出事情，因此保留设计的算法。

​		**有一点需要注意，如果删除整个目录**，比如删除/a/b，那么还是要遍历b的所有目录项以删除其全部子目录/文件，最后将数据块清空，然后对a的目录执行我们的算法。

#### Inode管理

​		删除文件时，Inode的内容需要清空，同时也要回收Inode

​		实际上，DiskInode在初始化的时候会进行清零，因此在删除时无需对其清空，只要修改位图即可

#### 数据块回收

和数据块匹配一样，遍历inode的索引并回收



#### 方法定义

```rust
//***** 磁盘块管理层efs *****
// 回收inode
pub fn dealloc_inode(&nut self, inode_id: u32)

//***** 索引节点层vfs (Inode) *****
// 删除文件/目录
pub fn remove(&self, path: Vec<&str>, type: DiskInodeType) -> bool
// 删除Inode对应的文件
fn remove_file(&self) -> bool
// 递归删除Inode对应的目录
fn remove_dir(&self) -> bool

//***** OSInode *****
pun fn remove(path: Vec<&str>, type: DiskInodeType) -> bool
```

#### 文件缩小

如何确定文件修改后的大小是一个问题。

实际上，文件中其实没有EOF这个东西。

C语言确实也没有提供删除文件内容的库。

在网上查阅资料，发现删除指定的内容时，一般是建立一个临时文件，然后把原文件的内容写入，跳过要删除的内容。

所以暂时不管。

### 互斥问题

#### 文件的删除

删除单个文件的时候，非常容易，但是当递归删除目录的时候，问题比较大。

因为每次都要获取目录下文件的inode，而很多inode存于一个块，同时，对blk_cache块的访问是上锁的，就会产生死锁

因此不能简单通过read/modify_disk_inode对下层信息控制

**方案1**

​		对block_cache的Inode单独上锁，而不是对整个块

​		这样会把diskinode直接暴露给vfs，相对来说增加了cache和layout的耦合度

​		但是比较具备针对性，可以很好的支持互斥

​		以后使用双cache策略的时候尤其有效

**方案2**

​		直接操作整个块，不利于递归，暴露更大，不可行

**方案3**

​		继续使用现有的接口。首先将当前目录下的Inode_id全部取出，然后遍历删除。

​		目前相对比较方便，且比较可靠有效

#### OSInode的锁

一般进程打开文件的时候，会新建立一个新的OSInode

注意到，SOInode的inner具备锁，fork的时候仅仅将Arc clone，也就是说，父子进程共用OSInode，所以要加锁

经过测试，Linux也是这样，如果fork前打开文件，父进程lseek，子进程也会跟着lseek；但如果子进程关闭，在打开，则offset又回到了原处。

#### 并发访问情形分析

单核情况下，理论上不会发生冲突，因为对文件的操作一般发生在内核，内核不会被时钟中断，因此进程对文件的操作过程是连续的。

但对于双核的情况，每个核运行不同的进程，达到真正的并行，那么就可能出现并发访问。

因此，当对磁盘进行修改时，将整个文件系统上锁，以避免多核的问题。

efs已经实现了锁，在很多细小的操作都会加锁，这导致高层方法调用的时候无法加锁。

例如remove:

```rust
fn remove(...)->bool{
    lock()
    target = find(..)
    // do sth...
}
```

find操作自身保证了互斥访问，但在find和do sth之间，其他核很可能对文件进行了修改，因此要对remove全局加锁

为此写了部分仅供文件系统内部访问的方法，均以nlock_开头，表示它们不会主动锁文件系统，在调用它们之前需要保证已经将文件系统上锁。

### 系统调用

|      | 系统调用号                | 描述             |
| ---- | ------------------------- | ---------------- |
| 1    | #define SYS_getcwd 17     | 获取当前工作目录 |
| 2    | #define SYS_pipe2 59      |                  |
| 3    | #define SYS_dup 23        |                  |
| 4    | #define SYS_dup3 24       |                  |
| 5    | #define SYS_chdir 49      |                  |
| 6    | #define SYS_openat 56     |                  |
| 7    | #define SYS_close 57      |                  |
| 8    | #define SYS_getdents64 61 |                  |
| 9    | #define SYS_read 63       |                  |
| 10   | #define SYS_write 64      |                  |
| 11   | #define SYS_linkat 37     |                  |
| 12   | #define SYS_unlinkat 3    |                  |
| 13   | #define SYS_mkdirat 34    |                  |
| 14   | #define SYS_umount2 39    |                  |
| 15   | #define SYS_mount 40      |                  |
| 16   | #define SYS_fstat 80      |                  |





### 用户端

DIR dirent

```c
struct dirent   
{   
　　long d_ino; /* inode number 索引节点号 */  
　　   
    off_t d_off; /* offset to this dirent 在目录文件中的偏移 */  
　　   
    unsigned short d_reclen; /* length of this d_name 文件名长 */  
　　   
    unsigned char d_type; /* the type of d_name 文件类型 */  
　　   
    char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */  
}  

struct __dirstream   
{   
    void *__fd;    
    char *__data;    
    int __entry_data;    
    char *__ptr;    
    int __entry_ptr;    
    size_t __allocation;    
    size_t __size;    
    __libc_lock_define (, __lock)    
};   
  
```



### 优化

真正的优化：减少数据块的读写

虚假的优化：死扣算法



### temp

目前传入的name都是&str，需要大规模改为path: Vec<&str>

![image-20210323222145846](C:\Users\Eobard\AppData\Roaming\Typora\typora-user-images\image-20210323222145846.png)