## MultiCore

### RustSBI

双核必须先对RustSBI进行修改。RustSBI实际上已经支持了双核，在一开始的配置之下，根据设定的最多支持核心数（实际上是hart数，但是现在单核对应一个hart，可以先看作核心数），m态获取到hartid，取出与最多支持核心数比较，多余的直接进入设定的死循环程序抛弃。但是这并不代表支持的核心就可以被唤醒。

#### 初始化

实际上，需要让一个核先做初始化，而非一开始就释放所有的核心运行。在RustSBI，要设置串口等硬件，将其配置至正确的状态，使其能够正确运行。这个时候，RustSBI会将非零号核心进入循环等待，反复读取中断值等待中断的到来（软中断）。这个中断是IPI，核间通信中断。关于硬件的中断，以及特权指令等等，本人都不知道（todo）。但是看了xv6的移植解决方案之后，看到其使用的方法为在s态ecall IPI，选定唤醒。这个时候，其他核就会唤醒，执行之后的操作，这个时候主核已经做好了所有的工作，因此该核心只需要关心自己核内部的初始化，然后进入os kernel。

#### 告知操作系统核心id

获取当前核心的id必须要在m态才能获取，反复的从s态陷入显然不符合设计，因此要从RustSBI将其传入s态。目前采用的办法是将其保存至tp寄存器，进入内核之后再获取。

### 内核UltraOS

#### 初始化

同样的，操作系统也要完成初始化，包括对进程、内存分配、页表等部分的初始化。当然，我们也要对核心本身做一部分初始化，因为有些数据不是共有的，而是每个核心所独占的。在主核初始化之后，要唤醒副核做自己的初始化。唤醒的时候也类似RustSBI，副核loop读取某个全局变量，主核初始化完成之后通过写这个变量使得副核跳出loop做自己的初始化。

##### 处理器管理器

目前主核要做两个初始化，一是Processor Manager，每个核都要拥有一个，并且据此来保存当前运行的PCB，并且实现进程调度。

##### 页表

每个处理器核的内核页表相同，但这并不意味着不需要设置。我们需要主动将页表挂载到CSR上，才能够正确访问内核栈等非一一映射的地址空间。注意还要清cache。

##### 中断

开启trap（指内核中断，用户中断会在返回用户前才开启），时钟等中断。但是这里我们没有关闭副核的一些外部中断，当出现一些外部中断的时候也许会导致多核同时响应，现在我们还没有遇到问题，暂时不考虑。

#### lazy_alloc

lazy_alloc按照现在的理解，是将数据存在堆中，但是其指针存在于全局变量之中。同时，对于其本体，一次也只会分配一个，也就是说使用lazy_alloc不会因为多核执行多次内核代码而分配多次数据，所有的核都共享这一个全局变量。如果我们要分配多个，那就要分配数组，或者是向量。现在多核最多两个，因此对于processor manager我们直接分配两个manager组成的数组，每次根据核心id来访问对应的manager。


### 问题

现在在forktest2的测试中偶见卡死，初步判断应该是出现了死锁。同时我们发现，当fork和sleep搭配的时候，就会出现包括操作系统卡死、僵尸进程未成功回收等情况。当我们将其放在rCoreTutorial的ch5分支（抛去了我们所有做的工作，同时还尽可能的简化了内核）上，还是在fork于sleep相关的地方发生了问题。报出的错误是instruction page fault，基本上可以猜测到是因为pc去向未定义地址处导致读出非预期数据，出发指令未识别错误。

对于卡死，我们发现基本都是在地址0xfffffffffffff04e附近卡死的，初步判定是虚地址，位于trampoline。

对于instruction page fault，gdb在trap from kernel设置断点，发现发生在pc=0，意味着程序在某时跳转到了0处，很有可能是ra变成了0.

#### 死锁（已解决）

在程序压力fork和sleep压力非常大的时候，会经常出现exit和yield，使得双核操作系统会经常同时处于内核态，并且频繁的同时进行进程调度与切换相关操作。其中出现问题的关键是：当双核同时处理进程exit时，并且其中一个是另一个的父进程，就会出现死锁，死锁出现在exit_current_and_run_next程序之中。该程序会以以下程序顺序获得锁：
- 获取当前进程的锁，以取出当前进程的孩子进程的指针
- 获取初始进程的锁，以准备将孩子进程挂载上去
- 依次获取孩子的锁，挂载

这样，当双核同时处理进程exit时，并且其中一个是另一个的父进程的时候，父进程获得当前进程和初始进程的锁，子进程获得了当前进程的锁。父进程想要获得孩子的锁，而孩子又想要获得初始进程的锁，而他们都被对方所获取，这就出现了死锁。


#### 程序跑飞而导致Instruction Page Fault（已解决）

这个死锁的直接结果就是在内核因为ra异常，程序运行在了没有设定的地址范围内。在排查之后，发现间接原因是task_cx被修改了。然后，使用gdb抓取出现Instruction Page Fault的时刻，也就是进入trap_from_kernel的时候，发现两个核使用的都是一个内核栈，而这并不符合内核的设定。正常来说，内核运行的栈严格和当前处理器核运行进程的pid绑定，或者转入idle_cx也就是初始栈，但这仍然不可能出现两个核处在相同的栈。结合task_cx的问题，我们推测是栈的切换过程之中出现了空隙，使得这种异常现象得以发生。

最后，我们发现，是切换的时候锁的控制出现了空隙。在内核进行进程切换的时候，先将当前进程放入空闲进程队列，再从队列中寻找下一个进程，这使得该核在使用该进程栈的同时，却有可能将该进程放手给了另一个核。

因此我们必须强制使得每个核必须手握至少一个进程的锁，也就是先找到下一个可以切换的进程，再将当前进程放入队列中。但是显然，这会造成死锁，所以我们采用了非常巧妙的方法，那就是：如果当前没有下一个进程，就不进行进程切换，返回原来的进程。这样的让出争抢锁的方式避免了死锁的发生可能。

具体操作我们还遇到了一些小问题：
- cpu运行第一个程序的时候核自身没有程序，这个时候不能“返回原来的进程”，要特殊判断，持续争抢下一个进程。
- 注意手动释放锁
- loop块的作用域等等细节实现问题