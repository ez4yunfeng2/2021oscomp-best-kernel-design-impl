## 问题

#### GetTime

该方法直接使用riscv库中的read scr的宏定义，将0XC01对应的寄存器读出，其代码为：

> ​         llvm_asm!("csrrs $0, $1, x0" : "=r"(r) : "i"($csr_number) :: "volatile");

它由编译器选择合适的寄存器，读出时钟CSR并赋值给usize变量r。最后优化出来的指令为

> rdtime $0

这里的$0由编译器决定，这样做表面上没有问题。但是实际上，K210的CSR读写指令的rd寄存器不能是所有寄存器，它只支持a0-a7以及s0-s6作为rd。这样的话我们就必须选定好对应的寄存器，而不能由编译器选定。因此我们将其改为

> asm!(
>
> ​      "rdtime a0",
>
> ​      inout("a0") time
>
> ​    );

读取time作为时间。


#### BusyBox运行

##### 现象1

0xf2e8地址处，pc跳转到0，出发指令异常。

> 0xf2d8:      jalr    t1,t3
>
> 0xf2dc:      nop
>
> 0xf2e0:      auipc   t3,0xe8
>
> 0xf2e4:      ld      t3,2024(t3)
>
> 0xf2e8:      jalr    t1,t3

###### 目前发现

在程序运行至结束，没有任何系统调用发生。这强烈暗示着，exec程序出现了问题。

尝试在exec busybox的时候加入参数，发生错误的地址（0xf2e8）不变。

存储有跳转地址的内存2024(t3)的数据一直为0.这个地址为f72e0+7e8=F7AC8

###### 结论

采用了动态bin文件，猜测跳转到了动态库，因此我们采用了静态bin文件。

##### 现象2

0x105c4跳入0xcb5c4地址处，随后在触发load page fault。
>[kernel] Exception(LoadPageFault) in application, bad addr = 0x3c37b13cb9b7b08, bad instruction = 0xcb608, core dumped.

运行busybox时输入参数sh，在同地触发异常，但是load 地址不同。
>[kernel] Exception(LoadPageFault) in application, bad addr = 0x34397ffffffcfe8, bad instruction = 0xcb608, core dumped.

###### 结论

exec的argv参数传递错误。userheap栈顶为argv，栈底为字符串序列（即参数），但是我们的实现却相反，将参数放置于栈顶，这是错误的，于是我们将其进行了调整。

##### 现象3

在此之前，调用了四种不同的id，使用了两次brk，共六次系统调用，程序运行已经很久，不再位于初始区域。在这个过程之中，tp为0，未被赋值过，但是被使用过。gp被使用过，也被赋值过。
>[kernel] Exception(StorePageFault) in application, bad addr = 0x0, bad instruction = 0x1326ae, core dumped.

###### 目前发现

发现我们选择的static bin不是测评的bin，我们自身重新生成了bin，和测评文件大小相同，然后重新进行了测试
>[kernel] Exception(StorePageFault) in application, bad addr = 0x0, bad instruction = 0xc50e2, core dumped.

访存12 13D0处地址，然后将其数据作为地址，存入s0的值，但是对应的地址为0，导致出错。查询后该地址位于GOT段，意味着这是全局变量地址。


###### 结论
我们观察了ELF文件中的GOT段，发现对应地址数据不为零。进一步的，我们使用GDB观察到，整个程序运行时GOT段数据为零，DATA段数据也为零。而整个程度分为两个程序区域，DATA和GOT都位于第二个程序区域，这强烈暗示，第二个程序区域的建立有着很大的问题，其数据没有成功的复制。
