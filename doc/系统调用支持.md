## 系统调用支持

#### Clone

Clone是一个较为复杂的系统调用，可以指定用户栈以及跳转函数，具体的ABI调用规则如下。

> **syscall(SYS_clone, flags, stack, ptid, tls, ctid)**

我们需要支持两个参数：flags和stack。stack指定了子进程的用户栈，而flags则暂定为SIGCHLD=17。

用户程序对clone进行了包装，应用了两个函数clone和fork。

##### fork

> syscall(SYS_clone, SIGCHLD, 0)

fork直接传递0为stack，表示创建的时候需要内核动态分配。

##### __clone

> __clone(fn, stack, flags, NULL, NULL, NULL);

这里的clone是用户态的clone，使用汇编语言进行了包装，其中fn是子程序执行的函数，它将会放在用户栈中，供创建的子进程调用，当子进程调用完毕之后，就以函数的范围值调用exit进行退出。相比__clone，fork则直接调用了系统调用，不需要在用户标准库进行包装。

##### 实现

做折中，我们依然分配已有的用户栈，只不过不使用，将其栈指针改为对应的指定内核栈，这样我们只需对syscall的clone进行适配即可。

#### Nanosleep

> int nanosleep(const struct timespec *req, struct timespec *rem)

req为内有秒和微秒的结构体指针，用来指示需要睡眠的时间。rem则需要内核填写，表示唤醒时与需要睡眠额时间相比还差多少，通常为零，系统调用通常返回0。如果出现了中途的中断，那么rem不会为零，系统调用也会返回-1。