## Dual Core

### RustSBI

双核必须先对RustSBI进行修改。RustSBI实际上已经支持了双核，在一开始的配置之下，根据设定的最多支持核心数（实际上是hart数，但是现在单核对应一个hart，可以先看作核心数），m态获取到hartid，取出与最多支持核心数比较，多余的直接进入设定的死循环程序抛弃。但是这并不代表支持的核心就可以被唤醒。

#### 初始化

实际上，需要让一个核先做初始化，而非一开始就释放所有的核心运行。在RustSBI，要设置串口等硬件，将其配置至正确的状态，使其能够正确运行。这个时候，RustSBI会将非零号核心进入循环等待，反复读取中断值等待中断的到来（软中断）。这个中断是IPI，核间通信中断。关于硬件的中断，以及特权指令等等，本人都不知道（todo）。但是看了xv6的移植解决方案之后，看到其使用的方法为在s态ecall IPI，选定唤醒。这个时候，其他核就会唤醒，执行之后的操作，这个时候主核已经做好了所有的工作，因此该核心只需要关心自己核内部的初始化，然后进入os kernel。

#### 告知操作系统核心id

获取当前核心的id必须要在m态才能获取，反复的从s态陷入显然不符合设计，因此要从RustSBI将其传入s态。目前采用的办法是将其保存至tp寄存器，进入内核之后再获取。

### 内核UltraOS

#### 初始化

同样的，操作系统也要完成初始化，包括对进程、内存分配、页表等部分的初始化。当然，我们也要对核心本身做一部分初始化，因为有些数据不是共有的，而是每个核心所独占的。在主核初始化之后，要唤醒副核做自己的初始化。唤醒的时候也类似RustSBI，副核loop读取某个全局变量，主核初始化完成之后通过写这个变量使得副核跳出loop做自己的初始化。

##### 处理器管理器

目前主核要做两个初始化，一是Processor Manager，每个核都要拥有一个，并且据此来保存当前运行的PCB，并且实现进程调度。

##### 页表

每个处理器核的内核页表相同，但这并不意味着不需要设置。我们需要主动将页表挂载到CSR上，才能够正确访问内核栈等非一一映射的地址空间。注意还要清cache。

##### 中断

开启trap（指内核中断，用户中断会在返回用户前才开启），时钟等中断。但是这里我们没有关闭副核的一些外部中断，当出现一些外部中断的时候也许会导致多核同时响应，现在我们还没有遇到问题，暂时不考虑。

#### lazy_alloc

lazy_alloc按照现在的理解，是将数据存在堆中，但是其指针存在于全局变量之中。同时，对于其本体，一次也只会分配一个，也就是说使用lazy_alloc不会因为多核执行多次内核代码而分配多次数据，所有的核都共享这一个全局变量。如果我们要分配多个，那就要分配数组，或者是向量。现在多核最多两个，因此对于processor manager我们直接分配两个manager组成的数组，每次根据核心id来访问对应的manager。


### 问题

现在在forktest2的测试中偶见卡死，初步判断应该是出现了死锁。

